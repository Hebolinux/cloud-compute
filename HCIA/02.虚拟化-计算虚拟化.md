# 虚拟化

虚拟化技术的实现是通过软件将物理资源转变为虚拟化资源，也叫逻辑资源，虚拟化具备一个专有的能力：将一个设备变为多个。虽然可以虚拟出多个设备，但实际性能还是受到物理设备性能的限制。**只有将一个物理设备的资源通过切片发布给多个用户使用才能够实现资源的复用**，提高物理设备的利用率



**计算机特权级别**

- Ring0：内核空间，特权级别，直接驱动硬件 - 特权指令
- Ring3：用户空间，非特权级别，用户向App发起请求，App调用OS的API接口 - 用户指令

```diff
- 如果在用户空间出现了特权指令，OS会将此指令拦截并捕捉，认为此操作是异常
```



#### 传统HostOS架构与虚拟化OS架构

​            **传统HostOS **                                                                                  **虚拟化OS**

|----------------------------------|                                               |---------------------------------------------------|

|                                          |                                               |   |-------------|   |-------------|                 | 

|                                          |                                                |   |    App    |    |    App    |   Ring3    |

|App     Ring3   用户空间  |                                               |   |     OS      |   |     OS      | 用户空间|

|                                          |                                               |   |    硬件    |    |    硬件    |                 |

|                                          |                                               |   |-------------|   |-------------|                 |   

|----------------------------------|                                               |---------------------------------------------------|

|HostOS  Ring0  内核空间|                                              |                         虚拟化OS                      |

|----------------------------------|                                               |---------------------------------------------------|

|                硬件                   |                                              |                            硬件                            |

|----------------------------------|                                               |---------------------------------------------------|

在传统HostOS架构中，应用（app）与OS紧密耦合，OS与硬件紧密耦合，所有与外网通信的**指令流/数据流**都由App拷贝到OS，然后由OS拷贝到硬件（硬盘）中，最后将硬盘中的数据输出到网络。此时如果能在数据传输的路径上忽略OS层，转而将数据直接从App层拷贝至硬盘（buffer），这样在HostOS架构中能够缩短数据I/O路径，有效降低时延提高吞吐量，此为**直通技术**

在虚拟化OS架构中，传统OS层被*虚拟化OS*取代，*虚拟化OS*直接与硬件耦合，并将物理硬件资源转化为虚拟化资源，为应用层的VM提供虚拟化的硬件资源，VM中的OS与*传统OS架构*中的宿主机OS相同，但在VM中被称为GuestOS，GuestOS不知道自身处于用户空间，也不知道自身使用的硬件是虚拟化资源，所以GuestOS会像*宿主机OS*一样使用自身的硬件，向自身的硬件发送**特权指令**，而VM的硬件收到特权指令时必然会被*虚拟化OS*捕捉

```diff
- 虚拟化技术就是先将HostOS与硬件解耦，这样HostOS和其上运行的应用可以看作一个整体，然后在硬件上在添加一个虚拟化OS层，将多个HostOS放置在一个虚拟化OS上运行，虚拟化OS为上层的HostOS提供虚拟化资源，这样HostOS在不知情的情况下调用虚拟化硬件来达到物理资源的复用
```

> **补充**

1. 物理设备的内存是划分**区域**的，App与OS都有自己专用的区域
2. 在数据传输的路径上忽略OS层并不是真正的完全忽略OS层，只是在指令调度的时候减少从App层到OS层的拷贝数据的机会
3. 虚拟化OS也被称为hypervisor或VMM（Virtual Machine Monitor），常见的虚拟化OS有ESXi，XEN等



#### 虚拟化的特点

1. **分区**：为了能够在一台物理设备上运行多个VM，必须通过软件（VMM）的方式，将硬件资源切分，然后为每一个VM提供一套虚拟化的硬件资源
2. **隔离**：不同的VM之间互不影响，各自的生命周期也不相同，每个VM只与VMM层发生调用关系
3. **封装**：由于虚拟化OS的出现，GuestOS与硬件解耦，所以每一个VM关机后，它就是VMM上的一个文件，而虚拟化OS又最大化的解决了不同硬件之间的兼容问题，所以在VMM层上的VM，能够非常便捷的在不同的硬件平台之间进行**迁移**
4. **独立**：作为一个文件来看，每一个VM都是独立存在的，可以在多个主机之间迁移



**虚拟化种类**

1. 完全虚拟化 | 性能低 | GuestOS对硬件完全无感知
2. 半虚拟化 | 性能中 | 部分知道自身处于虚拟化环境
3. 硬件辅助虚拟化 | 性能高 | 知道自身处于虚拟化环境

**资源种类**

1. 计算资源 -> 计算虚拟化 -> CPU、内存、IO
2. 网络资源 -> 网络虚拟化
3. 存储资源 -> 存储虚拟化

---

#### CPU虚拟化

- **全虚拟化**

  |----------------------------|											VMM为运行在其上的VM提供虚拟化CPU资源，全虚拟化场景下GuestOS是完全不知

  |             App               | Ring3								道自身运行在vCPU之上的，所以GuestOS任然会向CPU发送特权指令，而整个VM运

  |           GuestOS        |											行在用户态，*此时VM向CPU发送的特权指令必然会被hypervisor捕捉，hypervisor捕*

  |----------------------------|											*捉异常指令后将其翻译，然后再交给CPU*（此为上下文切换）这种方式被称为异常捕

  |        Hypervisor       |  Ring0								捉。但是在用户空间有一些指令，它不是特权指令，但又可以对硬件进行操作，这被

  |----------------------------|											称为**敏感指令**，而敏感指令不会被VMM捕捉，所以异常捕捉的方式现在已经不再适

  |         Hardware        |											用，**转而使用二进制翻译技术解决完全虚拟化场景下的敏感指令的捕捉翻译行为**。
  |----------------------------|											VM的GuestOS的代码一定会保存在VM所占用的物理内存的某一**区域**中，此时让

  ​																					VMM直接对VM占用的内存中的代码进行扫描，直接找到VM发出的敏感指令进行翻

  译，这就是二进制翻译技术。二进制翻译比较占用CPU资源，导致性能较弱

- **半虚拟化**

  在半虚拟化场景中，会对GuestOS内核的代码进行部分修改（安装插件），让VM知道自身处于VMM之上，所以VM就不会再直接发送特权指令，而是发送一个中断（hypercall)，VMM收到hypercall进行翻译即可

- **硬件辅助虚拟化**

  无论是全虚拟化或者半虚拟化，都是VM与VMM之间进行指令的调度和上下文的切换，而硬件辅助虚拟化则是直接在硬件层面就支持虚拟化，减少或者直接使VMM不再参与指令的调度，这样VM的指令就可以直达CPU，极大提升性能

> **补充**

硬件上支持虚拟化的CPU有两种工作模式：root mode / non-root mode，根模式下处理VMM内核发送过来的特权指令，而非根模式下处理VM发送过来的用户指令，CPU在两种不同的模式之间进行切换，执行VMM或VM的指令以保证主机安全性



# 计算虚拟化

**计算虚拟化的分类**

1. Ⅰ型虚拟化，也称为裸金属型虚拟化。在硬件上运行一个VMM，VM直接运行在VMM层上
2. Ⅱ型虚拟化，也称为宿主型虚拟化。在硬件上有一个宿主机OS，在HostOS上运行一个VMM应用，VMM应用上再运行VM

```diff
- 从架构上来看，Ⅰ型虚拟化比Ⅱ型虚拟化的数据传输路径要短，数据经过的软件层更少，意味着Ⅰ型虚拟化的性能更强
```

