# 计算虚拟化

**计算虚拟化的分类**

1. Ⅰ型虚拟化，也称为裸金属型虚拟化。在硬件上运行一个VMM，VM直接运行在VMM层上
2. Ⅱ型虚拟化，也称为宿主型虚拟化。在硬件上有一个宿主机OS，在HostOS上运行一个VMM应用，VMM应用上再运行VM

```diff
- 从架构上来看，Ⅰ型虚拟化比Ⅱ型虚拟化的数据传输路径要短，数据经过的软件层更少，意味着Ⅰ型虚拟化的性能更强
```



#### CPU虚拟化

- **全虚拟化**

  |----------------------------|											VMM为运行在其上的VM提供虚拟化CPU资源，全虚拟化场景下GuestOS是完全不知

  |             App              | Ring3								道自身运行在vCPU之上的，所以GuestOS任然会向CPU发送特权指令，而整个VM运

  |           GuestOS        |											行在用户态，*此时VM向CPU发送的特权指令必然会被hypervisor捕捉，hypervisor捕*

  |----------------------------|											*捉异常指令后将其翻译，然后再交给CPU*（此为上下文切换）这种方式被称为异常捕

  |        Hypervisor       |  Ring0								捉。但是在用户空间有一些指令，它不是特权指令，但又可以对硬件进行操作，这被

  |----------------------------|											称为**敏感指令**，而敏感指令不会被VMM捕捉，所以异常捕捉的方式现在已经不再适

  |         Hardware        |											用，**转而使用二进制翻译技术解决完全虚拟化场景下的敏感指令的捕捉翻译行为**。

  |----------------------------|											VM的GuestOS的代码一定会保存在VM所占用的物理内存的某一**区域**中，此时让

  VMM直接对VM占用的内存中的代码进行扫描，直接找到VM发出的敏感指令进行翻译，这就是二进制翻译技术。二进制翻译比较占用

  CPU资源，导致性能较弱

- **半虚拟化**

  在半虚拟化场景中，会对GuestOS内核的代码进行部分修改（安装插件），让VM知道自身处于VMM之上，所以VM就不会再直接发送特权指令，而是发送一个中断（hypercall)，VMM收到hypercall进行翻译即可。因为需要对GuestOS内核代码进行修改，所以用于半虚拟化场景中的GuestOS大多为开源操作系统

- **硬件辅助虚拟化**

  无论是全虚拟化或者半虚拟化，都是VM与VMM之间进行指令的调度和上下文的切换，而硬件辅助虚拟化则是直接在硬件层面就支持虚拟化，减少或者直接使VMM不再参与指令的调度，这样VM的指令就可以直达CPU，极大提升性能

> **补充**

硬件上支持虚拟化的CPU能够**自主识别用户空间和内核空间**，且CPU有**两种工作模式**：root mode / non-root mode，根模式下处理VMM内核发送过来的特权指令，而非根模式下处理VM发送过来的用户指令，CPU在两种不同的模式之间进行切换，执行VMM或VM的指令以保证主机安全性。*VM向CPU发送特权指令时，CPU会切换到根模式下执行*



#### 内存虚拟化

**传统HostOS内存映射**

|---------------------------|          |--------------------------|

|    App1        App2   |          | |0~∞|      |0~∞|  | 逻辑地址

|           HostOS         |          |             页表            | 映射

|             硬件             |          | |p1|  |p2|  |p3| | 物理内存页

|---------------------------|          |--------------------------|

 主机上的每个应用程序都有自己的内存空间，它们使用的内存地址都是**逻辑地址**，且这个逻辑地址也是一个**连续的不中断的**相对地址，地址范围是0到无穷大。在物理内存中，每个应用程序有自己的内存页，而主机分配给应用程序的内存页不可能是连续的，所以在HostOS上要维持一个页表，这个页表中记录了**应用程序的逻辑地址**与**主机内存的物理地址**的对应关系，HostOS通过页表将应用程序使用的连续的内存空间映射到其占用的不连续的物理内存页

```diff
- 物理内存是分页的
- 应用程序所使用的内存地址必须是连续不中断的地址空间，但由于内存的读写变化非常快，所以物理内存页几乎不可能提供连续不中断的内存页
- 页表也只是内存中维持的一种数据结构
```

> **补充**

有些资料将主机内存的物理地址称为MA/PA/HPA（Host Physical Addr）

---

​                       **虚拟化OS**

|------------------------------------------------|

| |------------------|   |-------------------| |

| |       APP        |   |         APP        | |

| |    GuestOS  |   |      GuestOS   | |   VM

| |------------------|   |--------------------| |

|-------------------------------------------------|

|  |  虚拟内存   |    |     虚拟内存    | |  VMM

|-------------------------------------------------|

|-------------------- 硬件 ---------------------|

虚拟化场景与HostOS场景的内存映射的运行逻辑差不多，虚拟化场景中有*两级页表*，VM中的APP的内存映射首先要经过GuestOS的*一级页表*，映射到虚拟内存，虚拟内存在经过VMM的*二级页表*映射到物理内存，华为官方对不同层的内存有专用的术语

- HPA - 物理内存
- GPA - 虚拟内存，GuestOS内存
- GLA - 逻辑地址

在硬件辅助虚拟化场景中，查询*二级页表*通过硬件实现，intel使用的是**EPT（Extended Page Table）技术**，AMD使用的是NPT技术，通过软件实现的从虚拟机映射到物理内存总体上也叫**影子页表**



#### I/O虚拟化

1. 完全虚拟化

   完全通过软件模拟VM需要的硬件，VMM在中间需要捕捉VM的指令，翻译后给具体的硬件。使用VM时不需要对GuestOS做出任何修改，可移植性非常好，但VMM过度参与指令的处理，导致性能差

2. 半虚拟化（基于XEN架构的半虚拟化）

   I/O虚拟化的半虚拟化场景中，VMM提供的VM中有一个特殊的**系统VM**，此VM不面向用户，而是属于**虚拟化环境中的一部分**，此*系统VM*向其他VM提供系统功能，此*系统VM*中存放硬件设备的**原生驱动**。这种设计模式将*原生驱动*模块化了，并将其放在一个安全的空间，使*原生驱动*与VMM分离，这是一种安全性的隔离，避免因为*原生驱动*的崩溃导致虚拟化的崩溃

   半虚与全虚的差异就在于半虚场景下，引用了一个**驱动**的概念，这个*驱动*分为**前驱（IO frontend）**和**后驱（IO backend）**，所有对面向用户的VM中都需要安装**前驱**，后驱安装在*系统VM*中，用户VM中的数据和指令都通过前驱发送到后驱，后驱将不同用户VM的指令**有序**发送到*原生驱动*

   半虚场景下，VMM层不再拦截VM的指令，所以半虚相较全虚，性能有所提升，但半虚受限于架构，它要将驱动分离为前后两端

3. 硬件辅助虚拟化

   IO-trough：IO透传，直接为VM分配物理设备，这需要IO硬件设备虚拟出多个虚拟硬件分配给VM，需要硬件支持IO透传技术

```diff
- 半虚场景下，无论是否存在用户VM，系统VM都是存在的，且系统VM会作为第一台启动的VM
```

